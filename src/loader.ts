/**
 * OMP Tool Loader Generator
 *
 * Generates ~/.pi/agent/tools/omp/index.ts with hardcoded tool paths.
 * No symlinks needed - tools are imported directly from node_modules.
 */

import { existsSync, mkdirSync, readFileSync, writeFileSync } from 'node:fs'
import { join } from 'node:path'
import { readPluginPackageJson } from '@omp/manifest'
import { GLOBAL_PACKAGE_JSON, getAgentDir } from '@omp/paths'

interface PluginInfo {
   tools?: string // e.g. "@oh-my-pi/exa/tools"
   runtime?: string // e.g. "@oh-my-pi/exa/tools/runtime.json"
}

/**
 * Get plugin info (tools and runtime paths) from installed plugins (global only)
 */
async function getPluginInfo(): Promise<Map<string, PluginInfo>> {
   if (!existsSync(GLOBAL_PACKAGE_JSON)) return new Map()

   const pkgJson = JSON.parse(readFileSync(GLOBAL_PACKAGE_JSON, 'utf-8'))
   const deps = { ...pkgJson.dependencies, ...pkgJson.devDependencies }

   const plugins = new Map<string, PluginInfo>()

   for (const pluginName of Object.keys(deps)) {
      const pluginPkgJson = await readPluginPackageJson(pluginName)
      if (!pluginPkgJson?.omp) continue

      const info: PluginInfo = {}
      if (pluginPkgJson.omp.tools) {
         info.tools = `${pluginName}/${pluginPkgJson.omp.tools}`
      }
      if (pluginPkgJson.omp.runtime) {
         info.runtime = `${pluginName}/${pluginPkgJson.omp.runtime}`
      }

      if (info.tools || info.runtime) {
         plugins.set(pluginName, info)
      }
   }

   return plugins
}

/**
 * Write the OMP loader with hardcoded tool paths and runtime redirects (global only)
 */
export async function writeLoader(): Promise<void> {
   const agentDir = getAgentDir()
   const ompDir = join(agentDir, 'tools', 'omp')

   mkdirSync(ompDir, { recursive: true })

   const plugins = await getPluginInfo()
   const toolPaths = [...plugins.values()].filter(p => p.tools).map(p => `"${p.tools}"`)

   // Build runtime redirects: maps full module path to store filename
   // e.g., "@oh-my-pi/exa/tools/runtime.json" -> "@oh-my-pi__exa.json"
   const runtimeRedirects: string[] = []
   for (const [name, info] of plugins) {
      if (info.runtime) {
         const storeName = name.replace(/\//g, '__') // @oh-my-pi/exa -> @oh-my-pi__exa
         runtimeRedirects.push(`  ["${info.runtime}", "${storeName}.json"]`)
      }
   }

   const source = `/**
 * OMP Tool Loader
 *
 * Auto-generated by omp. Do not edit.
 */

import * as fs from "node:fs";
import * as path from "node:path";
import { fileURLToPath } from "node:url";
import type { CustomToolFactory, CustomAgentTool } from "@mariozechner/pi-coding-agent";

// ============================================================================
// Tool registry (regenerated on plugin install/uninstall)
// ============================================================================

const toolPaths = [
${toolPaths.map(p => ` ${p}`).join(',\n')}
];

// Runtime config: [moduleSpecifier, storeFilename]
const runtimeConfigs: [string, string][] = [
${runtimeRedirects.join(',\n')}
];

// ============================================================================
// Bootstrap: Patch module resolution and load runtime configs from store
// ============================================================================

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const piDir = path.resolve(__dirname, "../../.."); // ~/.pi
const pluginNodeModules = path.join(piDir, "plugins/node_modules");
const globalStoreDir = path.join(piDir, "plugins/store");
const projectStoreDir = path.join(process.cwd(), ".pi/store");

// Ensure global store directory exists
fs.mkdirSync(globalStoreDir, { recursive: true });

if (fs.existsSync(pluginNodeModules)) {
   try {
      const Module = await import("node:module");
      const ModuleClass = (Module as any).default?.Module || (Module as any).Module;

      // Patch _nodeModulePaths to include plugins/node_modules
      if (ModuleClass?._nodeModulePaths) {
         const original = ModuleClass._nodeModulePaths;
         ModuleClass._nodeModulePaths = (from: string) => {
            const paths = original(from);
            if (!paths.includes(pluginNodeModules)) {
               paths.push(pluginNodeModules);
            }
            return paths;
         };
      }
   } catch (e) {
      console.error("omp-loader: Failed to patch module resolution:", e);
   }
}

// Load runtime configs: import module, read global store, merge project store (local precedence)
for (const [moduleSpec, storeFile] of runtimeConfigs) {
   try {
      const runtime = await import(moduleSpec);
      const globalStorePath = path.join(globalStoreDir, storeFile);
      const projectStorePath = path.join(projectStoreDir, storeFile);
      
      // Start with global store
      if (fs.existsSync(globalStorePath)) {
         const globalData = JSON.parse(fs.readFileSync(globalStorePath, "utf-8"));
         Object.assign(runtime.default, globalData);
      }
      
      // Merge project store (takes precedence)
      if (fs.existsSync(projectStorePath)) {
         const projectData = JSON.parse(fs.readFileSync(projectStorePath, "utf-8"));
         Object.assign(runtime.default, projectData);
      }
   } catch {
      // Module not found or store read failed - skip
   }
}

// ============================================================================
// Tool loader factory
// ============================================================================

const factory: CustomToolFactory = async (pi) => {
   const allTools: CustomAgentTool[] = [];

   for (const toolPath of toolPaths) {
      try {
         const module = await import(toolPath);
         const pluginFactory = module.default as CustomToolFactory;

         if (typeof pluginFactory !== "function") {
            console.error(\`omp-loader: \${toolPath} does not export a factory function\`);
            continue;
         }

         const result = await pluginFactory(pi);
         const resultTools = Array.isArray(result) ? result : [result];
         allTools.push(...resultTools);
      } catch (e) {
         console.error(\`omp-loader: Failed to load \${toolPath}:\`, e);
      }
   }

   return allTools;
};

export default factory;
`

   writeFileSync(join(ompDir, 'index.ts'), source, 'utf-8')
}

/**
 * Check if the OMP loader exists (global only)
 */
export function loaderExists(): boolean {
   const agentDir = getAgentDir()
   return existsSync(join(agentDir, 'tools', 'omp', 'index.ts'))
}
